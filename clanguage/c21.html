
<html>
	<head>
		<title>Codopedia.com:C - File I/O  </title>
		<link rel="stylesheet" href="..\css\page.css">
		<link rel="stylesheet" href="..\css/font/fontawesome/css/all.min.css">
	</head>
	<body id="body">
		

<div id="navbarContainer"></div>

		<span class="mid">

		<div id="sidebarContainer"></div>
		<div class="content">
			<p id="content_heading">C - File System </p>
			<div id="content_text">
				  <p>The last chapter explained the standard input and output devices handled by C programming language. This chapter cover how C programmers can create, open, close text or binary files for their data storage.</p>
<p>A file represents a sequence of bytes, regardless of it being a text file or a binary file. C programming language provides access on high level functions as well as low level (OS level) calls to handle file on your storage devices. This chapter will take you through the important calls for file management.</p>

<span class="sub_point">Opening Files</span> <br>
<p>You can use the fopen( ) function to create a new file or to open an existing file. This call will initialize an object of the type FILE, which contains all the information necessary to control the stream. The prototype of this function call is as follows −
</p>
<pre>FILE *fopen( const char * filename, const char * mode );</pre>
<p>Here, filename is a string literal, which you will use to name your file, and access mode can have one of the following values −</p>
<p>If you are going to handle binary files, then you will use following access modes instead of the above mentioned ones −</p>
<pre>"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"
</pre>
<span class="sub_point"> Closing a File:</span> <br>
<p>To close a file, use the fclose( ) function. The prototype of this function is −<p>
  <pre>int fclose( FILE *fp );</pre>
  <p>The fclose(-) function returns zero on success, or EOF if there is an error in closing the file. This function actually flushes any data still pending in the buffer to the file, closes the file, and releases any memory used for the file. The EOF is a constant defined in the header file stdio.h.</p>
  <p>There are various functions provided by C standard library to read and write a file, character by character, or in the form of a fixed length string.</p>
<span class="sub_point"> Writing a File</span> <br>
<p>Following is the simplest function to write individual characters to a stream −
</p>
<pre>int fputc( int c, FILE *fp );</pre>
<p>The function fputc() writes the character value of the argument c to the output stream referenced by fp. It returns the written character written on success otherwise EOF if there is an error. You can use the following functions to write a null-terminated string to a stream −</p>
<pre>int fputs( const char *s, FILE *fp );</pre>
<p>The function fputs() writes the string s to the output stream referenced by fp. It returns a non-negative value on success, otherwise EOF is returned in case of any error. You can use int fprintf(FILE *fp,const char *format, ...) function as well to write a string into a file. Try the following example.</p>
<p>Make sure you have /tmp directory available. If it is not, then before proceeding, you must create this directory on your machine.</p>
<pre>v</pre>
<p>When the above code is compiled and executed, it creates a new file test.txt in /tmp directory and writes two lines using two different functions. Let us read this file in the next section.</p>

<span class="sub_point"> Reading a File</span> <br>
<p>Given below is the simplest function to read a single character from a file −</p>
<pre>int fgetc( FILE * fp );</pre>
<p>The fgetc() function reads a character from the input file referenced by fp. The return value is the character read, or in case of any error, it returns EOF. The following function allows to read a string from a stream −</p>
<pre>char *fgets( char *buf, int n, FILE *fp );</pre>
<p>The functions fgets() reads up to n-1 characters from the input stream referenced by fp. It copies the read string into the buffer buf, appending a null character to terminate the string.</p>
<p>v</p>
<pre>#include <stdio.h>

  main() {
  
     FILE *fp;
     char buff[255];
  
     fp = fopen("/tmp/test.txt", "r");
     fscanf(fp, "%s", buff);
     printf("1 : %s\n", buff );
  
     fgets(buff, 255, (FILE*)fp);
     printf("2: %s\n", buff );
     
     fgets(buff, 255, (FILE*)fp);
     printf("3: %s\n", buff );
     fclose(fp);
  
  }</pre>
  <p>When the above code is compiled and executed, it reads the file created in the previous section and produces the following result −</p>
  <pre>1 : This
    2: is testing for fprintf...
    
    3: This is testing for fputs...</pre>
    <p>Let's see a little more in detail about what happened here. First, fscanf() read just This because after that, it encountered a space, second call is for fgets() which reads the remaining line till it encountered end of line. Finally, the last call fgets() reads the second line completely.</p>

</p>
</div>
		<div class="circle-btn">
			<a href="c20.html" class="circle-left-btn"><i class="fas fa-chevron-circle-left"></i></a>
			<a href="c22.html" class="circle-right-btn"><i class="fas fa-chevron-circle-right"></i></a>
		</div>		
		</div>
		</span>
	<footer >

		<div id="footerContainer"></div>

	</footer>
	<script src="https://code.jquery.com/jquery-3.4.1.js"></script>
	<script>
		$(document).ready(function () {
			// Load sidebar content dynamically
			$('#sidebarContainer').load('sidebar.html');
			$('#footerContainer').load('../footer.html');
			$('#navbarContainer').load('../navbar.html');
			// Your existing JavaScript for handling sidebar interactions goes here

			// Redirect to link on click
			$('nav a').on('click', function () {
				var link = $(this).attr('href');
				$('iframe').attr('src', link);
			});
		});
	</script>
	</body>
</html>